<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Monologue.js by postaljs</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Monologue.js</h1>
        <h2>Observer pattern based pub/sub utility (similar to event emitter). Compliments mediator-pattern-focused postal.js</h2>
        <a href="https://github.com/postaljs/monologue.js" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>monologue.js</h1>

<h3>What is it?</h3>

<p>monologue provides 'event-emitting' functionality - commonly referred to as "pub/sub" - that can be mixed into/inherited by your JavaScript objects.</p>

<h5>Philosophy</h5>

<p>monologue's pub/sub implementation uses the observer pattern - meaning that subscribers should have a direct reference to the 'monologue-ized' object emitting the events.  This is in contrast to monologue's sister library, <a href="https://github.com/ifandelse/postal.js">postal.js</a>, which uses the mediator pattern to relieve publishers and subscribers from the need to have a direct reference to each other.  Putting a monologue instance in the prototype chain of an object turns  it into an "event emitter". This is incredibly useful in organizing how other <em>local</em> (within a limited scope/module) instances are notified of something the object wants to publish. monologue is designed to be bridged with <a href="https://github.com/ifandelse/postal.js">postal.js</a> if you want to 'promote' an event into an app-level message - and the <a href="https://github.com/ifandelse/monopost.js">monopost</a> add-on exists to do just that.  </p>

<h5>Really? Another Event Emitter?</h5>

<p>I know, right?!  There are a number of EventEmitter implementations that are very useful (and compact) - my favorite of which is <a href="https://github.com/hij1nx/EventEmitter2">EventEmitter2</a>. So why did I write monologue? Three main reasons:</p>

<ul>
<li>
<strong>I wanted postal/AMQP-like wildcard binding semantics.</strong>  The "*" wildcard matches exactly one word in a topic, while the "#" wildcard matches 0-n words.</li>
<li>
<strong>I prefer an "envelope" payload in an event vs passing 0-n arguments to a subscriber callback.</strong>  This means we get a consistent callback signature everywhere. Consistency causes kittens to turn into angels and get their wings.</li>
<li>
<strong>I wanted safe invocation of subscriber callbacks.</strong> Most Event Emitter style implementations (that I've seen) blindly fire the subscriber callback - and if the callback throws an uncaught exception, the entire event-emit breaks. "But won't a try/catch slow things down?" Yes, there is a performance hit. I've asked myself these two questions: How many times has an event emitter been the bottleneck in my app? And how many times has a subscriber callback been guilty of tanking the app? In my experience, the latter happens <strong>far more often</strong> than the former. </li>
</ul><h3>Why should I use it?</h3>

<p>If you want to extend your objects with the ability to trigger custom events, take advantage of the wildcard binding options, trust that subscriber callbacks can't tank the emitter while it's triggering events, and/or have consistent callback signatures, then monologue might be for you.</p>

<h3>How do I use it?</h3>

<h5>Adding monologue functionality to an instance</h5>

<p>You can use the <code>mixin</code> helper function, which mixes Monologue into the prototype of your object:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Worker</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">Worker</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">doWork</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">"work.done"</span><span class="p">,</span> <span class="p">{</span> <span class="nx">who</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="p">});</span>
<span class="p">};</span>
<span class="nx">Monologue</span><span class="p">.</span><span class="nx">mixin</span><span class="p">(</span><span class="nx">Worker</span><span class="p">);</span>
</pre></div>

<p>You can also manually put a monologue instance in the prototype chain of an object:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Worker</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">Worker</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Monologue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">Worker</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">doWork</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">"work.done"</span><span class="p">,</span> <span class="p">{</span> <span class="nx">who</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="p">});</span>
<span class="p">};</span>
</pre></div>

<p>An alternative (&amp; less preferred) approach would be to 'mix-in' to an existing instance via a helper like <a href="http://underscorejs.org/">underscore's</a> <a href="http://underscorejs.org/#extend">extend</a> call:</p>

<div class="highlight"><pre><span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span>
    <span class="nx">plainJane</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="nx">doWork</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">"work.done"</span><span class="p">,</span> <span class="p">{</span> <span class="nx">who</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="k">new</span> <span class="nx">Monologue</span><span class="p">());</span>
</pre></div>

<h5>Adding an event listener</h5>

<p>Any object that has monologue's behavior has an <code>on</code> method which can be used to subscribe to events.  The first argument of <code>on()</code> is the <code>topic</code> (just a string event name, which can optionally be a period-delimited string for hierarchical use).  The second argument of <code>on()</code> is the <code>callback</code> which should be invoked when the event occurs. Calling <code>on</code> returns a <code>SubscriptionDefinition</code> - giving you a convenient way to unsubscribe or apply additional options (discussed below) to the subscription.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">();</span> <span class="c1">// get an instance of something that has monologue's behavior</span>

<span class="c1">// subscribe to listen for 'some.event'</span>
<span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"some.event"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Something happened thanks to "</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>As you can see in the example above, the subscription callback takes two arguments: <code>data</code> and <code>envelope</code>.  Like many facets of monologue, this matches the behavior of postal.js.  The <code>data</code>
argument is simply the data published when the event was emitted.  The <code>envelope</code> provides additional metadata about the event, and can be customized to fit your needs.  By default, the envelope has three members: <code>data</code>, <code>topic</code> and <code>timeStamp</code>.  For example:</p>

<div class="highlight"><pre><span class="c1">// pretending we're inside of a monologue-ized object:</span>
<span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">"some.event"</span><span class="p">,</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">'bar'</span><span class="p">,</span> <span class="nx">baz</span><span class="o">:</span> <span class="s1">'bacon'</span> <span class="p">});</span>

<span class="c1">// pretending we're somewhere else setting up the subscriber:</span>
<span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"some.event"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="cm">/* </span>
<span class="cm">      data would look like:</span>
<span class="cm">        {</span>
<span class="cm">            foo: 'bar',</span>
<span class="cm">            baz: 'bacon'</span>
<span class="cm">        }</span>

<span class="cm">      envelope would look like:</span>
<span class="cm">        {</span>
<span class="cm">            topic: 'some.event',</span>
<span class="cm">            timeStamp: '2012-10-21T02:53:10.287Z',</span>
<span class="cm">            data: {</span>
<span class="cm">                foo: 'bar',</span>
<span class="cm">                baz: 'bacon'</span>
<span class="cm">            }</span>
<span class="cm">        }</span>
<span class="cm">    */</span>    
<span class="p">});</span> 
</pre></div>

<h5>Wildcard Subscriptions</h5>

<p>As mentioned above, the <code>*</code> and <code>#</code> characters represent wildcards available when you subscribe to events. Topics are string values, and are often period-delimited. The part of the topic delimited by a period is called a 'word'. Using a <code>*</code> represents exactly one word in a topic, while the <code>#</code> character matches 0-n words.  For example:</p>

<div class="highlight"><pre><span class="c1">// The topic binding below will match "name.changed" and "city.changed"</span>
<span class="c1">// but it will not match "changed" or "user.location.changed"</span>
<span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"*.changed"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">});</span>

<span class="c1">// The topic binding below will match "name.changed", "city.changed"</span>
<span class="c1">// "changed" and "user.location.changed"</span>
<span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"#.changed"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">});</span>

<span class="c1">// Also - you can use the wildcards together:</span>
<span class="c1">// this binding will match user.email.validation.failed, user.zip.validation.success</span>
<span class="c1">// as well as password.validation.success, but NOT customer.order.validation.retry.cancel</span>
<span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"#.validation.*"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">});</span>
</pre></div>

<h5>Unsubscribing</h5>

<p>You have four possible ways to remove event listeners in monologue:</p>

<h6>Removing a specific listener</h6>

<p>When you use <code>on</code> to subscribe to an event, it returns a <code>SubscriptionDefinition</code> object. This object contains several helper methods, one of which is <code>unsubscribe</code>:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"#.changed"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">});</span>

<span class="nx">subscription</span><span class="p">.</span><span class="nx">unsubscribe</span><span class="p">();</span>
</pre></div>

<h6>Removing all listeners for a topic</h6>

<p>However, you can also call the <code>off</code> method on the monlogue-ized event emitter object:</p>

<pre><code>var subscription = instance.on("#.changed", function(data, envelope){
    // handle event data here….
});

// remove just this one subscription
instance.off(subscription);

// remove all subscriptions for a topic
instance.off("#.changed");
</code></pre>

<h6>Removing all listeners for a topic/context combination</h6>

<p>One of the SubscriptionDefinition helper methods is <code>withContext</code> - which allows you to specifiy the <code>this</code> context you want to apply to the subscription callback when it is invoked. Because of this, it's possible to remove all listeners for a specific topic that are using a particular 'context':</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">subscription</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"#.changed"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">}).</span><span class="nx">withContext</span><span class="p">(</span><span class="nx">someObject</span><span class="p">);</span>

<span class="c1">// remove just this one subscription</span>
<span class="nx">instance</span><span class="p">.</span><span class="nx">off</span><span class="p">(</span><span class="nx">subscription</span><span class="p">);</span>

<span class="c1">// remove all subscriptions for the topic + context combination</span>
<span class="nx">instance</span><span class="p">.</span><span class="nx">off</span><span class="p">(</span><span class="s2">"#.changed"</span><span class="p">,</span> <span class="nx">someObject</span><span class="p">);</span>
</pre></div>

<h6>Removing ALL listeners, period.</h6>

<p>This is the 'nuke it from orbit' option. Simply call <code>off</code> with no arguments, and all subscriptions will be removed from the object.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">subscriptionA</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"#.changed"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">}).</span><span class="nx">withContext</span><span class="p">(</span><span class="nx">someObject</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">subscriptionB</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">"*.moar"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">envelope</span><span class="p">){</span>
    <span class="c1">// handle event data here….</span>
<span class="p">}).</span><span class="nx">withContext</span><span class="p">(</span><span class="nx">someOtherObject</span><span class="p">);</span>

<span class="c1">// buh-bye all subscriptions...</span>
<span class="nx">instance</span><span class="p">.</span><span class="nx">off</span><span class="p">();</span>
</pre></div>

<h5>Subscription Options</h5>

<p>As mentioned above - the <code>SubscriptionDefinition</code> object returned from a call to the <code>on</code> method provides some additional fluent configuration options:</p>

<ul>
<li>**<code>withContext(object)</code>** - the provided argument becomes the <code>this</code> context inside the subscription callback.</li>
<li>
<strong><code>defer</code></strong> - delays the invocation of the callback until the event loop is free (via setTimeout of 0 milliseconds).</li>
<li>
<strong><code>disposeAfter(count)</code></strong> - automatically unsubscribes the subscription after the number of invocations specified.</li>
<li>
<strong><code>once</code></strong> - a shortcut to disposeAfter(1).</li>
<li>
<strong><code>distinctUntilChanged</code></strong> - keeps track of the last data published with an event and only invokes the callback if the new data differs from the old data.</li>
<li>
<strong><code>distnct</code></strong> - keeps track of the data published with an event and only invokes the callback if it's different from anything published previously.</li>
<li>
<strong><code>withConstraint(predicateFn)</code></strong> - the predicateFn argument is a function with the same signature as the subscriber callback (data,envelope).  Returning true from this function will cause the subscription callback to be invoked, returning false will prevent it from firing.</li>
<li>**<code>withConstraints([predicateFns])</code>** - same as <code>withConstraint</code>, but it takes an array of predicates instead of one.</li>
<li>
<strong><code>withDebounce(milliseconds)</code></strong> - uses underscore's debounce function to cause the subscription callback to only be invoked a minimum of {x} milliseconds after the events cease being published.</li>
<li>
<strong><code>withDelay(milliseconds)</code></strong> - delays invocation of the subscriber callback for the number of milliseconds specified.</li>
<li>
<strong><code>withThrottle(milliseconds)</code></strong> - causes the subscriber callback to be invoked at most once per {x} milliseconds interval.</li>
</ul><h5>Other Monologue Options</h5>

<h6>Customizing the Envelope</h6>

<p>Any object that has been extended with Monologue's behavior will have a <code>getEnvelope</code> method which you can override to customize how the envelope is created. The default implementation looks like this:</p>

<div class="highlight"><pre><span class="c1">// The default implementation just marks the envelope with a time stamp.</span>
<span class="c1">// The topic and data are attached to the envelope just before it's published</span>
<span class="nx">getEnvelope</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">topic</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">timeStamp</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>

<p>Note that the topic and data being published are passed in for optional use - allowing you to configure envelope data at run time, based on the event in progress.</p>

<h6>Error Tracking</h6>

<p>One of the core features of monologue is that subscriber callbacks won't be able to crash the event emitter with uncaught exceptions. While developers <strong>should</strong> be cleaning up after themselves (and not crashing things with uncaught exceptions), they don't always do so. We don't want to simply swallow those exceptions, so by default monologue will store them in an aptly named <code>_yuno</code> member - which is an array of objects, where each object contains the subscription definition instance that threw the uncaught exception, as well as the envelope being published at the time of the event.  You can turn error tracking off by setting the <code>_trackErrors</code> member to <code>false</code>:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">Worker</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">Worker</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Monologue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">();</span>
<span class="nx">instance</span><span class="p">.</span><span class="nx">_trackErrors</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</pre></div>

<h5>Customizing Wildcard Bindings</h5>

<p>Just like it's sister library postal.js, monologue's bindingsResolver object can be overridden with your own implementation. Don't like how AMQP's wildcards work? Want to create something that uses different characters, or logic in matching topics? All you have to do is create an object that implements a <code>compare(binding, topic)</code> method (where <code>binding</code> is the topic value used when a subscriber was added and <code>topic</code> is the actual topic of the event being published).  This function should return true for a match, or false otherwise.  Simply create your own resolver and replace the existing resolver with your own:</p>

<div class="highlight"><pre><span class="nx">Monologue</span><span class="p">.</span><span class="nx">resolver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">compare</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">binding</span><span class="p">,</span> <span class="nx">topic</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// The magic happens here….</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/postaljs/monologue.js/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/postaljs/monologue.js/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/postaljs/monologue.js"></a> is maintained by <a href="https://github.com/postaljs">postaljs</a>.</p>

          <p>This page was generated by <a href="pages.github.com">GitHub Pages</a> using the Architect theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>